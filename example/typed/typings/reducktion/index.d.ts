declare module 'reducktion' {
  // Helper
  type ArgumentType<F extends Function> = F extends (arg: infer A) => any
    ? A
    : never;

  // TODO: do we need this?
  interface RootState<StatePart> {
    [statePart: string]: StatePart;
  }

  type Selector<State> = (state: RootState<State>, ...args: any[]) => any;

  // Provide action keys for auto-complete but allow custom types
  // that are eg. auto-generated by fetchable action
  type ActionTypes<Actions> = { [K in keyof Actions]: string } & {
    [x: string]: string;
  };

  interface ActionCreator<Payload> {
    type: string;
    payload: Payload;
    [x: string]: any; // Allow additional meta fields
  }

  type ActionFunc<Payload = any> = (
    payload?: Payload
  ) => ActionCreator<Payload>;

  type Thunk<Deps> = (
    arg: any,
    deps: Deps
  ) => (dispatch: any, getState: () => any, ...args: any[]) => Promise<void>;

  type Reducer<State, Payload = any> = (
    state: State,
    action: ActionCreator<Payload>
  ) => State;

  interface FetchableReducers<State> {
    loading: Reducer<State>;
    success: Reducer<State>;
    failure: Reducer<State>;
  }

  interface Fetchable {
    value: <T>(val: T) => FetchableValue<T>;
    action: <State, K extends keyof State>(
      // Only allow state fields for fetchable values
      stateField: FetchableValue extends State[K] ? K : never,
      customReducers?: Partial<FetchableReducers<State>>
    ) => FetchableReducers<State>;
  }

  interface Dependencies {
    [depName: string]: Model<any, any>;
  }

  // TODO:
  // Figure out how to show proper error
  // if given action is not in keyof Actions
  interface ModelDefinition<State, Actions, Deps> {
    name: string;
    inject?: [keyof Deps];
    state: State;
    actions: (
      { initialState }: { initialState: State }
    ) => {
      // Only include those keys that are present in the action's interface
      [K in keyof Actions]: Actions[K] extends FetchableAction<any>
        ? FetchableReducers<State>
        : Actions[K] extends Function
        ? Reducer<State, ArgumentType<Actions[K]>>
        : never
    };
    reactions?: (
      { initialState, deps }: { initialState: State; deps: Deps }
    ) => {
      [depType: string]: Reducer<State>;
    };
    selectors?: (
      { name }: { name: string }
    ) => {
      [selectorName: string]: Selector<State>;
    };
    sagas?: (
      { types, deps }: { types: ActionTypes<Actions>; deps: Deps }
    ) => any[];
    // TODO: fix thunks...
    thunks?: {
      [thunkName: string]: Thunk<Deps>;
    };
  }

  interface Model<State, Actions> {
    name: string;
    initialState: State;
    types: ActionTypes<Actions>;
    actions: Actions;
    selectors: {
      get: <K extends keyof State>(
        stateField: K
      ) => (state: RootState<State>, ...args: any[]) => Pick<State, K>[K];
    };
    getSagas: () => [];
    getReducer: () => Reducer<any>;
  }

  // EXPORTS ********************************************************************

  export enum FetchableStatus {
    INITIAL,
    LOADING,
    SUCCESS,
    FAILURE,
  }

  export interface FetchableValue<Data = any> {
    data: Data;
    error: any;
    status: FetchableStatus;
  }

  export interface FetchableAction<SuccessData> extends ActionFunc {
    init: ActionFunc;
    fail: ActionFunc;
    success: ActionFunc<SuccessData>;
  }

  export const fetchable: Fetchable;

  export function createModel<State, Actions, Deps = Dependencies>(
    df: ModelDefinition<State, Actions, Deps>
  ): Model<State, Actions>;

  export function initModels(
    models: Model<any, any>[]
  ): {
    allReducers: {
      [x: string]: Reducer<any>;
    };
    allSagas: any[];
  } & {
    [modelName: string]: Model<any, any>;
  };
}
