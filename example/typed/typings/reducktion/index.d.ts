declare module 'reducktion' {
  export enum STATUSES {
    INITIAL,
    LOADING,
    SUCCESS,
    FAILURE,
  }

  export interface Fetchable<Data = any> {
    data: Data;
    error: any;
    status: STATUSES;
  }

  interface FullState<StatePart> {
    [statePart: string]: StatePart;
  }

  type Selector<State> = (state: FullState<State>, ...args: any[]) => any;

  interface Selectors<State> {
    [selectorName: string]: Selector<State>;
  }

  interface Thunks {
    [thunkName: string]: (args: any, deps?: any) => any;
  }

  // Provide action keys for auto-complete but allow custom types
  // that are eg. auto-generated by fetchableAction
  type Types<Actions> = { [K in keyof Actions]: string } & {
    [x: string]: string;
  };

  interface Action<Payload = any> {
    type: string;
    payload: Payload;
    [x: string]: any; // Allow additional meta fields
  }

  type Reducer<State, Payload = any> = (
    state: State,
    action: Action<Payload>
  ) => State;

  type ActionCreator<Payload = any> = (payload?: Payload) => Action<Payload>;

  interface FetchableReducers<State> {
    loading: Reducer<State>;
    success: Reducer<State>;
    failure: Reducer<State>;
  }

  export interface FetchableAction<SuccessData> extends ActionCreator {
    init: ActionCreator;
    fail: ActionCreator;
    success: ActionCreator<SuccessData>;
  }

  // Only include those keys that are present in the action's interface
  // TODO: figure out how to show proper error if given action is not in keyof Actions
  type ActionReducers<State, Actions> = {
    [K in keyof Actions]: Reducer<State> | FetchableReducers<State>
  };

  interface DuckDefinition<State, Actions> {
    name: string;
    inject?: string[];
    state: State;
    actions: (
      { initialState }: { initialState: State }
    ) => ActionReducers<State, Actions>;
    selectors?: ({ name }: { name: string }) => Selectors<State>;
    sagas?: ({ types, deps }: { types: Types<Actions>; deps: any }) => any[];
    thunks?: Thunks;
    reactions?: (
      { initialState, deps }: { initialState: State; deps: any }
    ) => Reducer<State>;
  }

  interface Duck<State, Actions> {
    name: string;
    initialState: State;
    types: Types<Actions>;
    actions: Actions;
    selectors: {
      // TODO: fix `get` return value type!
      get: (stateField: keyof State) => Selector<State>;
    };
    getSagas: () => any;
    getReducer: () => any;
  }

  export function createDuck<State, Actions>(
    df: DuckDefinition<State, Actions>
  ): Duck<State, Actions>;

  interface IAllReducers {
    [x: string]: Reducer<any>;
  }

  // TODO: Not sure if these need to be typed properly...
  interface InitedDucks {
    allReducers: IAllReducers;
    allSagas: any[];
    [x: string]: any; // Ducks by name - TODO: fix!
  }

  export function initDucks(ducks: Duck<any, any>[]): InitedDucks;

  // TODO: Make sure state field is for a fetchable value!
  export function fetchableAction<State, K extends keyof State>(
    stateField: keyof State,
    // stateField: State[K] extends Fetchable ? K : never,
    customReducers?: Partial<FetchableReducers<State>>
  ): FetchableReducers<State>;

  export function fetchable<T>(val: T): Fetchable<T>;
}
