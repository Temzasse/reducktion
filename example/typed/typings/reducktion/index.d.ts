declare module 'reducktion' {
  export enum STATUSES {
    INITIAL,
    LOADING,
    SUCCESS,
    FAILURE,
  }

  export interface Fetchable<Data = any> {
    data: Data;
    error: any;
    status: STATUSES;
  }

  interface RootState<StatePart> {
    [statePart: string]: StatePart;
  }

  type Selector<State> = (state: RootState<State>, ...args: any[]) => any;

  interface Dependencies {
    [depName: string]: Duck<any, any>;
  }

  // Provide action keys for auto-complete but allow custom types
  // that are eg. auto-generated by fetchableAction
  type Types<Actions> = { [K in keyof Actions]: string } & {
    [x: string]: string;
  };

  interface ActionCreator<Payload = any> {
    type: string;
    payload: Payload;
    [x: string]: any; // Allow additional meta fields
  }

  type Reducer<State, Payload = any> = (
    state: State,
    action: ActionCreator<Payload>
  ) => State;

  type ActionFunc<Payload = any> = (payload?: Payload) => ActionCreator<Payload>;

  interface ActionsDict {
    [actionName: string]: ActionFunc;
  }

  interface FetchableReducers<State> {
    loading: Reducer<State>;
    success: Reducer<State>;
    failure: Reducer<State>;
  }

  export interface FetchableAction<SuccessData> extends ActionFunc {
    init: ActionFunc;
    fail: ActionFunc;
    success: ActionFunc<SuccessData>;
  }

  type Thunk<Deps> = (
    arg: any,
    deps: Deps
  ) => (dispatch: any, getState: () => any, ...args: any[]) => Promise<void>;

  interface DuckDefinition<State, Actions, Deps> {
    name: string;
    inject?: string[];
    state: State;
    // Only include those keys that are present in the action's interface
    // TODO: figure out how to show proper error if given action is not in keyof Actions
    actions: (
      { initialState }: { initialState: State }
    ) => { [K in keyof Actions]: Reducer<State> | FetchableReducers<State> };
    selectors?: (
      { name }: { name: string }
    ) => {
      [selectorName: string]: Selector<State>;
    };
    sagas?: ({ types, deps }: { types: Types<Actions>; deps: Deps }) => any[];
    thunks?: {
      [thunkName: string]: Thunk<Deps>;
    };
    reactions?: (
      { initialState, deps }: { initialState: State; deps: Deps }
    ) => {
      [depType: string]: Reducer<State>;
    };
  }

  interface Duck<State, Actions> {
    name: string;
    initialState: State;
    types: Types<Actions>;
    actions: Actions;
    selectors: {
      // TODO: fix `get` return value type!
      get: (stateField: keyof State) => Selector<State>;
    };
    getSagas: () => any;
    getReducer: () => any;
  }

  export function createDuck<State, Actions, Deps = Dependencies>(
    df: DuckDefinition<State, Actions, Deps>
  ): Duck<State, Actions>;

  interface IAllReducers {
    [x: string]: Reducer<any>;
  }

  // TODO: Not sure if these need to be typed properly...
  interface InitedDucks {
    allReducers: IAllReducers;
    allSagas: any[];
    [x: string]: any; // Ducks by name - TODO: fix!
  }

  export function initDucks(ducks: Duck<any, any>[]): InitedDucks;

  export function fetchableAction<State, K extends keyof State>(
    // Only allow state fields for fetchable values
    stateField: Fetchable extends State[K] ? K : never,
    customReducers?: Partial<FetchableReducers<State>>
  ): FetchableReducers<State>;

  export function fetchable<T>(val: T): Fetchable<T>;
}
