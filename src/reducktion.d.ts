interface RootState<StatePart> {
  [statePart: string]: StatePart;
}

// Provide action keys for auto-complete but allow custom types
// that are eg. auto-generated by fetchableAction
type ActionTypes<Actions> = { [K in keyof Actions]: string } & {
  [x: string]: string;
};

interface ActionCreator<Payload = any> {
  type: string;
  payload: Payload;
  [x: string]: any; // Allow additional meta fields
}

type ActionFunc<Payload = any> = (
  payload?: Payload
) => ActionCreator<Payload>;

type Selector<State> = (state: RootState<State>, ...args: any[]) => any;

type Thunk<Deps> = (
  arg: any,
  deps: Deps
) => (dispatch: any, getState: () => any, ...args: any[]) => Promise<void>;

type Reducer<State, Payload = any> = (
  state: State,
  action: ActionCreator<Payload>
) => State;

interface FetchableReducers<State> {
  loading: Reducer<State>;
  success: Reducer<State>;
  failure: Reducer<State>;
}

interface Dependencies {
  [depName: string]: Duck<any, any>;
}

// TODO:
// Figure out how to show proper error
// if given action is not in keyof Actions
interface DuckDefinition<State, Actions, Deps> {
  name: string;
  inject?: string[];
  state: State;
  actions: (
    { initialState }: { initialState: State }
  ) => {
    // Only include those keys that are present in the action's interface
    [K in keyof Actions]: Reducer<State> | FetchableReducers<State>
  };
  reactions?: (
    { initialState, deps }: { initialState: State; deps: Deps }
  ) => {
    [depType: string]: Reducer<State>;
  };
  selectors?: (
    { name }: { name: string }
  ) => {
    [selectorName: string]: Selector<State>;
  };
  sagas?: (
    { types, deps }: { types: ActionTypes<Actions>; deps: Deps }
  ) => any[];
  thunks?: {
    [thunkName: string]: Thunk<Deps>;
  };
}

interface Duck<State, Actions> {
  name: string;
  initialState: State;
  types: ActionTypes<Actions>;
  actions: Actions;
  selectors: {
    get: <K extends keyof State>(
      stateField: K
    ) => (state: RootState<State>, ...args: any[]) => Pick<State, K>[K];
  };
  getSagas: () => [];
  getReducer: () => Reducer<any>;
}

// EXPORTS
// Exported types -----------------------------------------------------------

export enum STATUSES {
  INITIAL,
  LOADING,
  SUCCESS,
  FAILURE,
}

export interface Fetchable<Data = any> {
  data: Data;
  error: any;
  status: STATUSES;
}

export interface FetchableAction<SuccessData> extends ActionFunc {
  init: ActionFunc;
  fail: ActionFunc;
  success: ActionFunc<SuccessData>;
}

// Exported functions -------------------------------------------------------

export function createDuck<State, Actions, Deps = Dependencies>(
  df: DuckDefinition<State, Actions, Deps>
): Duck<State, Actions>;

export function initDucks(
  ducks: Duck<any, any>[]
): {
  allReducers: {
    [x: string]: Reducer<any>;
  };
  allSagas: any[];
} & {
  [duckName: string]: Duck<any, any>;
};

export function fetchableAction<State, K extends keyof State>(
  // Only allow state fields for fetchable values
  stateField: Fetchable extends State[K] ? K : never,
  customReducers?: Partial<FetchableReducers<State>>
): FetchableReducers<State>;

export function fetchable<T>(val: T): Fetchable<T>;